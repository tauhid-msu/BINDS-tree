!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	config.h	/^int A[] = {ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA$/;"	v
ALPHA	config.h	/^const int ALPHA=4;$/;"	v
BITS_PER_BYTE	utility.h	/^const int BITS_PER_BYTE = 8;$/;"	v
BOX_SIZE_START_AT	config.h	/^const int BOX_SIZE_START_AT = 1;$/;"	v
BOX_SIZE_STEP	config.h	/^const int BOX_SIZE_STEP = 1;$/;"	v
BOX_SIZE_STOP_BEFORE	config.h	/^const int BOX_SIZE_STOP_BEFORE = A[0];$/;"	v
BYTES_PER_DIM_IN_DMBR	config.h	/^const int BYTES_PER_DIM_IN_DMBR = ((ALPHA%8)==0)?(ALPHA\/8):(ALPHA\/8+1);$/;"	v
CNTDIM	config.h	/^const int CNTDIM = 0; $/;"	v
CONFIG_H	config.h	2;"	d
DIM	config.h	/^const int DIM = 18;$/;"	v
DIR_ENTRY_H	Dir_entry.h	2;"	d
DIR_NODE_H	Dir_node.h	2;"	d
DIR_NODE_OVERHEAD	Dir_node.h	/^const int DIR_NODE_OVERHEAD = 4; \/\/ int count$/;"	v
DIR_NODE_SIZE	Dir_node.h	/^   static const int DIR_NODE_SIZE =  (DISK_BLOCK_SIZE - DIR_NODE_OVERHEAD) \/ (DMBR_SIZE + sizeof(unsigned int));$/;"	m	class:Dir_node
DIR_NODE_SIZE	ND_tree.h	/^   static const int DIR_NODE_SIZE =  (DISK_BLOCK_SIZE - DIR_NODE_OVERHEAD) \/ (DMBR_SIZE + sizeof(unsigned int));$/;"	m	class:ND_tree
DMBR	Dir_entry.h	/^   unsigned char DMBR[DMBR_SIZE]; \/\/ Digital Minimum Bounding Rectangle$/;"	m	struct:Dir_entry
DMBR_bit_lut	Node.h	/^    int DMBR_bit_lut[DIM][MAX_ALPHABET_SIZE]; \/\/ Given a dim and a letter, store the coresponding bit in DMBR$/;"	m	class:Node
DMBR_byte_lut	Node.h	/^    int DMBR_byte_lut[DIM][MAX_ALPHABET_SIZE]; \/\/ Given a dim and a letter, store the coresponding byte in DMBR$/;"	m	class:Node
DMBR_end_byte_lut	Node.h	/^    int DMBR_end_byte_lut[DIM]; \/\/ Given a dim, store the coresponding end byte in DMBR$/;"	m	class:Node
DMBR_start_byte_lut	Node.h	/^    int DMBR_start_byte_lut[DIM]; \/\/ Given a dim, store the coresponding start byte in DMBR$/;"	m	class:Node
DOUBLE_INF	utility.h	/^const double DOUBLE_INF = numeric_limits<double> :: max( );$/;"	v
DOUBLE_THRESHOLD	utility.h	/^const double DOUBLE_THRESHOLD = 1E-14;$/;"	v
Dir_entry	Dir_entry.h	/^struct Dir_entry{$/;"	s
Dir_node	Dir_node.h	/^Dir_node::Dir_node(int* alphabet_sizes):Node(alphabet_sizes){$/;"	f	class:Dir_node
Dir_node	Dir_node.h	/^class Dir_node:public Node{$/;"	c
ENVIRONMENT	config.h	/^enum ENVIRONMENT {UNIX, WINDOWS};$/;"	g
Error_code	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	g
GCC	makefile	/^GCC=g++$/;"	m
INT_INF	utility.h	/^const int INT_INF = numeric_limits<int> :: max( );$/;"	v
Knapsack_recursive_forNDTree	utility.cpp	/^vector<int> Knapsack_recursive_forNDTree($/;"	f
LEAF_ENTRY_H	Leaf_entry.h	4;"	d
LEAF_NODE_OVERHEAD	Leaf_node.h	/^const int LEAF_NODE_OVERHEAD = 4; \/\/ int count$/;"	v
LEAF_NODE_SIZE	Leaf_node.h	/^    static const int LEAF_NODE_SIZE =  (DISK_BLOCK_SIZE - LEAF_NODE_OVERHEAD) \/ sizeof(Leaf_entry);$/;"	m	class:Leaf_node
LEAF_NODE_SIZE	ND_tree.h	/^    static const int LEAF_NODE_SIZE =  (DISK_BLOCK_SIZE - LEAF_NODE_OVERHEAD) \/ sizeof(Leaf_entry);$/;"	m	class:ND_tree
LOGCLASS	logClass.h	2;"	d
Leaf_entry	Leaf_entry.h	/^struct Leaf_entry$/;"	s
Leaf_node	Leaf_node.h	/^Leaf_node::Leaf_node(int* alphabet_sizes):Node(alphabet_sizes)$/;"	f	class:Leaf_node
Leaf_node	Leaf_node.h	/^class Leaf_node:public Node {$/;"	c
LinearScanBoxQuery	main.cpp	/^void LinearScanBoxQuery(int dataNUM)$/;"	f
LocalDMBRInfoCalculation	main.cpp	/^void LocalDMBRInfoCalculation()$/;"	f
MASKS	utility.h	/^const unsigned char MASKS[] = {1, 2, 4, 8, 16, 32, 64, 128};$/;"	v
MAX_ALPHABET_SIZE	Node.h	/^const int MAX_ALPHABET_SIZE = 255; \/\/ Define the maximum length of the ND-tree file name$/;"	v
MAX_DMBR_DIM_SIZE	Node.h	/^const int MAX_DMBR_DIM_SIZE = (MAX_ALPHABET_SIZE - 1) \/ BITS_PER_BYTE + 1; \/\/ in bytes, max bitmap size for one dimension of DMBR$/;"	v
MAX_LINE_IN_SOURCE_FILE	config.h	/^const int MAX_LINE_IN_SOURCE_FILE = 1000000;$/;"	v
NDT_sort	utility.cpp	/^void NDT_sort(int count, double* weight_list, int* sorted_index_list, bool asc){$/;"	f
NDT_sort	utility.cpp	/^void NDT_sort(int count, unsigned int* weight_list){$/;"	f
NDT_sort	utility.cpp	/^void NDT_sort(unsigned int* a, int lo, int hi)$/;"	f
NDT_stable_sort	utility.cpp	/^void NDT_stable_sort(int count, double* weight_list, int* sorted_index_list, bool asc){$/;"	f
ND_FILE_NAME_LENGTH	ND_tree.h	/^const int ND_FILE_NAME_LENGTH = 256; \/\/ Define the maximum length of the ND-tree file name$/;"	v
ND_TREE_H	ND_tree.h	2;"	d
ND_file	ND_tree.h	/^   fstream ND_file;$/;"	m	class:ND_tree
ND_file_name	ND_tree.h	/^   char ND_file_name[ND_FILE_NAME_LENGTH]; \/\/ The name of the ND-tree file$/;"	m	class:ND_tree
ND_tree	ND_tree.h	/^ND_tree::ND_tree(){$/;"	f	class:ND_tree
ND_tree	ND_tree.h	/^class ND_tree{$/;"	c
ND_tree_record	config.h	/^typedef int ND_tree_record;$/;"	t
ND_tree_record_count	config.h	/^typedef int ND_tree_record_count;$/;"	t
NODE_H	Node.h	2;"	d
Node	Node.h	/^Node::Node(int* alphabet_sizes)$/;"	f	class:Node
Node	Node.h	/^class Node$/;"	c
OPT_BQFILE	main.cpp	734;"	d	file:
OPT_COUNT	main.cpp	738;"	d	file:
OPT_DSCDIM	main.cpp	731;"	d	file:
OPT_HELP	main.cpp	740;"	d	file:
OPT_LOADFILE	main.cpp	732;"	d	file:
OPT_NEW	main.cpp	739;"	d	file:
OPT_RANGE	main.cpp	736;"	d	file:
OPT_RECORDFILE	main.cpp	733;"	d	file:
OPT_RQFILE	main.cpp	735;"	d	file:
OPT_SKIP	main.cpp	737;"	d	file:
OPT_TREEFILE	main.cpp	730;"	d	file:
OutStream	main.cpp	/^ofstream OutStream;$/;"	v
QUERY_RESULTS_BUFFER_SIZE	config.h	/^const int QUERY_RESULTS_BUFFER_SIZE = 1000;$/;"	v
RANGE_SIZE_STEP	config.h	/^const int RANGE_SIZE_STEP = 1;$/;"	v
RUNNING_ENVIRONMENT	config.h	/^ENVIRONMENT RUNNING_ENVIRONMENT = UNIX;$/;"	v
TOTAL_BOX_QUERY_NUM	config.h	/^const int TOTAL_BOX_QUERY_NUM = 1000;$/;"	v
TOTAL_CNT_VALUE	config.h	/^const int TOTAL_CNT_VALUE =8;\/\/total CNT values to be read out$/;"	v
TOTAL_DSC_VALUE	config.h	/^const int TOTAL_DSC_VALUE =8; \/\/total DSC values to be read out$/;"	v
TOTAL_RANGE_QUERY_NUM	config.h	/^const int TOTAL_RANGE_QUERY_NUM =200;$/;"	v
UNDEF_LONG	main.cpp	742;"	d	file:
UNDEF_STR	main.cpp	741;"	d	file:
UNIX	config.h	/^enum ENVIRONMENT {UNIX, WINDOWS};$/;"	e	enum:ENVIRONMENT
UTILITY_H	utility.h	2;"	d
WINDOWS	config.h	/^enum ENVIRONMENT {UNIX, WINDOWS};$/;"	e	enum:ENVIRONMENT
alphabet_sizes	ND_tree.h	/^   int alphabet_sizes[DIM]; \/\/ Dynamic array of alphabet sizes$/;"	m	class:ND_tree
aux_tree_node	Dir_node.h	/^	  aux_tree_node(){$/;"	f	struct:Dir_node::aux_tree_node
aux_tree_node	Dir_node.h	/^	  aux_tree_node(const aux_tree_node& orig) {$/;"	f	struct:Dir_node::aux_tree_node
aux_tree_node	Dir_node.h	/^   struct aux_tree_node{$/;"	s	class:Dir_node
available_block_numbers	ND_tree.h	/^   stack<unsigned int> available_block_numbers; \/\/ The block numbers (<= max_block_number) of the nodes being deleted and become available again$/;"	m	class:ND_tree
batchBoxQuery	main.cpp	/^void batchBoxQuery()$/;"	f
batchBuild_with_duplicate	main.cpp	/^void batchBuild_with_duplicate(long  size)$/;"	f
batchBuild_with_duplicate_record	main.cpp	/^void batchBuild_with_duplicate_record(long  size)$/;"	f
batchGrow_with_duplicate	main.cpp	/^void batchGrow_with_duplicate(long skipSize, long sizeGrowTo)$/;"	f
batchRandomBoxQuery	main.cpp	/^void batchRandomBoxQuery()$/;"	f
batchRangeQuery	main.cpp	/^void batchRangeQuery(    )$/;"	f
binary2string	utility.cpp	/^void binary2string(const unsigned char* const ptr, int lengthInBytes, string & resultString)$/;"	f
bit_1_count_lut	utility.h	/^const int bit_1_count_lut[] = { \/\/ 256 entries$/;"	v
bit_mask	utility.h	/^const unsigned char bit_mask[] = {1,2,4,8,16,32,64,128};\/\/set corresponding bit to 1, others to 0$/;"	v
bitmap_bit_lut	Node.h	/^    int bitmap_bit_lut[MAX_ALPHABET_SIZE]; \/\/ Given a letter, store the coresponding bit in a bitmap$/;"	m	class:Node
bitmap_byte_lut	Node.h	/^    int bitmap_byte_lut[MAX_ALPHABET_SIZE]; \/\/ Given a letter, store the coresponding byte in a bitmap$/;"	m	class:Node
bitmap_to_letters	Node.h	/^void Node::bitmap_to_letters(unsigned char* bitmap_set, int byte_size, unsigned char* letters, int &letter_count)$/;"	f	class:Node
box_query	ND_tree.h	/^void ND_tree::box_query($/;"	f	class:ND_tree
bqfile	main.cpp	/^    string bqfile;\/\/ box query file$/;"	m	struct:options	file:
cal_DMBR	Dir_node.h	/^void Dir_node::cal_DMBR(Dir_entry* dir_entries, int num_of_dir_entries, unsigned char* new_DMBR){$/;"	f	class:Dir_node
cal_DMBR	Dir_node.h	/^void Dir_node::cal_DMBR(Dir_entry* dir_entries, int* indices_of_dir_entries_used, int num_of_dir_entries_used, unsigned char* new_DMBR){$/;"	f	class:Dir_node
cal_DMBR	Dir_node.h	/^void Dir_node::cal_DMBR(vector<Dir_entry> &  dir_entries, int* indices_of_dir_entries_used, int num_of_dir_entries_used, unsigned char* new_DMBR){$/;"	f	class:Dir_node
cal_DMBR	Dir_node.h	/^void Dir_node::cal_DMBR(vector<Dir_entry> & dir_entries, int num_of_dir_entries, unsigned char* new_DMBR){$/;"	f	class:Dir_node
cal_normed_area	Node.h	/^double Node::cal_normed_area(unsigned char* DMBR, int* alphabet_sizes)$/;"	f	class:Node
cal_normed_overlap	Node.h	/^double Node::cal_normed_overlap(unsigned char* DMBR1, unsigned char* DMBR2, int* alphabet_sizes)$/;"	f	class:Node
child	Dir_entry.h	/^   unsigned int child; \/\/ Block number of the child of the current entry$/;"	m	struct:Dir_entry
children	Dir_node.h	/^      int children[MAX_ALPHABET_SIZE];$/;"	m	struct:Dir_node::aux_tree_node
choose_subtree	ND_tree.h	/^unsigned int ND_tree::choose_subtree(Leaf_entry &new_data, int &number_of_io, stack<unsigned int>& node_stack, stack<int>& index_stack){$/;"	f	class:ND_tree
clearLogs	logClass.cpp	/^void logClass::clearLogs(string fileName)$/;"	f	class:logClass
cnt	Dir_node.h	/^      int cnt; \/\/ number of children$/;"	m	struct:Dir_node::aux_tree_node
cntkey	Leaf_entry.h	/^    float cntkey[CNTDIM]; \/\/ Continuous dimensions. A string of CNTDIM floating point values. $/;"	m	struct:Leaf_entry
count	Dir_node.h	/^   int count; \/\/ curent number of entries in the node$/;"	m	class:Dir_node
count	Leaf_node.h	/^    int count; \/\/ curent number of entries in the node$/;"	m	class:Leaf_node
count	main.cpp	/^    long count;$/;"	m	struct:options	file:
create_DMBR	Leaf_node.h	/^void Leaf_node::create_DMBR(Leaf_entry* leaf_entries, int num_of_leaf_entries, unsigned char* new_DMBR)$/;"	f	class:Leaf_node
create_DMBR	Leaf_node.h	/^void Leaf_node::create_DMBR(Leaf_entry* leaf_entries, int* indices_of_leaf_entries_used, int num_of_leaf_entries_used, unsigned char* new_DMBR){$/;"	f	class:Leaf_node
create_empty_tree	ND_tree.h	/^void ND_tree::create_empty_tree($/;"	f	class:ND_tree
datafile	main.cpp	/^    string datafile;$/;"	m	struct:options	file:
debug_boxQ_leaf_accessed	main.cpp	/^int debug_boxQ_leaf_accessed=0;$/;"	v
debug_boxQ_leaf_hit	main.cpp	/^int debug_boxQ_leaf_hit=0;$/;"	v
debug_boxQ_leaf_hit_for_all	main.cpp	/^vector<int> debug_boxQ_leaf_hit_for_all;$/;"	v
debug_boxQ_leaf_hit_peak	main.cpp	/^int debug_boxQ_leaf_hit_peak=0;$/;"	v
debug_height	main.cpp	/^int debug_height;$/;"	v
decide_order_by_aux_tree	Dir_node.h	/^void Dir_node::decide_order_by_aux_tree(aux_tree_node* tree, int root, int letters_bitmap_byte_size, set_entry* set_entry_array, int set_entry_array_size, int* sorted_set_list, int& list_size){$/;"	f	class:Dir_node
dir_min_util	ND_tree.h	/^   double dir_min_util;$/;"	m	class:ND_tree
dir_min_util	main.cpp	/^const double dir_min_util = ((nodeSplitType==ORIGINAL)||(enforce_minUtil_for_exhaustSplit==1))?0.3:0.0000000000003;$/;"	v
display_help	main.cpp	/^void display_help()$/;"	f
duplicateDataPoints	main.cpp	/^int duplicateDataPoints; \/\/used in batchBuild(...), batchGrow(...)$/;"	v
duplicate_error	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	e	enum:Error_code
element_size	Dir_node.h	/^      int element_size; \/\/ num of elements in the set$/;"	m	struct:Dir_node::set_entry
enlarge_DMBR	Dir_node.h	/^void Dir_node::enlarge_DMBR(unsigned char* DMBR, const Leaf_entry &new_data){$/;"	f	class:Dir_node
entries	Leaf_node.h	/^    Leaf_entry entries[LEAF_NODE_SIZE];$/;"	m	class:Leaf_node
entriesVec	Dir_node.h	/^	vector<Dir_entry> entriesVec;$/;"	m	class:Dir_node
entry_set	Dir_node.h	/^      int *entry_set; \/\/ entries (indices) whose component set corresponds to the set_entry$/;"	m	struct:Dir_node::set_entry
entry_set	Leaf_node.h	/^        int entry_set[LEAF_NODE_SIZE + 1]; \/\/ entries (indices) whose letter corresponds to the letter_entry$/;"	m	struct:Leaf_node::letter_entry
exact_query_use_link	ND_tree.h	/^Error_code ND_tree::exact_query_use_link(Leaf_entry &query_data, int &number_of_io){$/;"	f	class:ND_tree
fail	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	e	enum:Error_code
find_best_child	Dir_node.h	/^void Dir_node::find_best_child(const Leaf_entry &new_data, int* alphabet_sizes, unsigned int& child_block_no, int& child_index){$/;"	f	class:Dir_node
find_covering_entries	Dir_node.h	/^void Dir_node::find_covering_entries(const Leaf_entry &query_data, vector<int> &covered_block_numbers){$/;"	f	class:Dir_node
find_entries_by_box_query	Dir_node.h	/^void Dir_node::find_entries_by_box_query($/;"	f	class:Dir_node
find_entries_by_hamming_dist	Dir_node.h	/^void Dir_node::find_entries_by_hamming_dist(const Leaf_entry &query_data, int range, vector<int>& block_numbers_in_range){$/;"	f	class:Dir_node
find_minOverlap_by_aux_tree	Dir_node.h	/^void Dir_node::find_minOverlap_by_aux_tree(int sort_dim, Dir_entry* sort_entries,aux_tree_node* tree, int root, int letters_bitmap_byte_size, set_entry* set_entry_array, int set_entry_array_size, vector<int> & leftSets,  double & rst_overlap)$/;"	f	class:Dir_node
freq	Dir_node.h	/^      int freq; \/\/ number of entries whose set corresponds to the set in sets$/;"	m	struct:Dir_node::aux_tree_node
freq	Dir_node.h	/^      int freq; \/\/ number of entries whose set corresponds to the set_entry$/;"	m	struct:Dir_node::set_entry
freq	Leaf_node.h	/^        int freq; \/\/ number of entries whose letter corresponds to the letter_entry$/;"	m	struct:Leaf_node::letter_entry
getCompressedDiskSize	Dir_node.h	/^int Dir_node::getCompressedDiskSize(vector<Dir_entry> & tmp_entries, int *alphabet_sizes)$/;"	f	class:Dir_node
getCompressedEntriesSize	Dir_node.h	/^int Dir_node::getCompressedEntriesSize(vector<Dir_entry> & tmp_entries, int *alphabet_sizes)$/;"	f	class:Dir_node
get_DMBR	Dir_node.h	/^void Dir_node::get_DMBR(unsigned char* cur_DMBR){$/;"	f	class:Dir_node
get_DMBR	Dir_node.h	/^void Dir_node::get_DMBR(unsigned char* cur_DMBR,int index)$/;"	f	class:Dir_node
get_DMBR	Leaf_node.h	/^void Leaf_node::get_DMBR(unsigned char* cur_DMBR)$/;"	f	class:Leaf_node
get_block_number	ND_tree.h	/^unsigned int ND_tree::get_block_number()$/;"	f	class:ND_tree
get_node_count	Dir_node.h	/^int Dir_node::get_node_count(){$/;"	f	class:Dir_node
get_node_count	Leaf_node.h	/^int Leaf_node::get_node_count()$/;"	f	class:Leaf_node
get_node_entry	Dir_node.h	/^void Dir_node::get_node_entry(int index, Dir_entry& cur_entry){$/;"	f	class:Dir_node
get_node_entry	Leaf_node.h	/^void Leaf_node::get_node_entry(int index, Leaf_entry& cur_entry){$/;"	f	class:Leaf_node
get_options	main.cpp	/^void get_options(int argc, char **argv, struct options *opt)$/;"	f
get_single_DMBR	Leaf_node.h	/^void Leaf_node::get_single_DMBR(unsigned char* cur_DMBR,int index)$/;"	f	class:Leaf_node
get_tree_size	ND_tree.h	/^unsigned int ND_tree::get_tree_size(){$/;"	f	class:ND_tree
globalBQFilename	main.cpp	/^string globalBQFilename = "..\/data\/box_query_random";$/;"	v
globalDataFilename	main.cpp	/^string globalDataFilename = "..\/data\/data_random";$/;"	v
globalIndexFilename	main.cpp	/^string globalIndexFilename = "ndTree.dat";$/;"	v
globalRQFilename	main.cpp	/^string globalRQFilename = "rangequeryAll.txt";$/;"	v
height	ND_tree.h	/^   int height; \/\/ The height of the tree$/;"	m	class:ND_tree
help	main.cpp	/^    bool help;$/;"	m	struct:options	file:
idxfile	main.cpp	/^    string idxfile;$/;"	m	struct:options	file:
index	Dir_node.h	/^      int index; \/\/ If set, index of a set_entry.  If roots, index in the aux_tree$/;"	m	struct:Dir_node::mixed_list_entry
insert_new_data	Leaf_node.h	/^Error_code Leaf_node::insert_new_data(Leaf_entry &new_data, double leaf_min_util, int* alphabet_sizes, unsigned char* cur_DMBR, Leaf_node*& new_leaf_node, unsigned char* new_DMBR)$/;"	f	class:Leaf_node
insert_new_entry	Dir_node.h	/^Error_code Dir_node::insert_new_entry(unsigned int new_entry_block_no, unsigned char* new_entry_DMBR, double dir_min_util, int *alphabet_sizes, unsigned char* cur_DMBR, Dir_node*& new_dir_node, unsigned char* new_DMBR){$/;"	f	class:Dir_node
insert_use_link	ND_tree.h	/^Error_code ND_tree::insert_use_link(Leaf_entry &new_data, int &number_of_io){$/;"	f	class:ND_tree
int_to_string	logClass.cpp	/^string logClass::int_to_string(int i){$/;"	f	class:logClass
int_to_string	utility.cpp	/^string int_to_string(int i){$/;"	f
is_covered	Dir_node.h	/^bool Dir_node::is_covered(const Leaf_entry &query_data, unsigned char* DMBR){$/;"	f	class:Dir_node
is_set	Dir_node.h	/^      bool is_set; \/\/ true: sets, false: roots$/;"	m	struct:Dir_node::mixed_list_entry
is_within_Hamming_dist	Dir_node.h	/^bool Dir_node::is_within_Hamming_dist(const Leaf_entry &query_data, unsigned char* DMBR, int range){$/;"	f	class:Dir_node
is_within_box	Dir_node.h	/^bool Dir_node::is_within_box($/;"	f	class:Dir_node
is_within_box	Leaf_node.h	/^bool Leaf_node::is_within_box(const unsigned char box_query_data_DMBR[DMBR_SIZE], unsigned char* DMBR)$/;"	f	class:Leaf_node
key	Leaf_entry.h	/^    unsigned char key[DIM]; \/\/ Key: a string of DIM characters, represented as 0 to (alphabet_size-1)$/;"	m	struct:Leaf_entry
leaf_min_util	ND_tree.h	/^   double leaf_min_util;$/;"	m	class:ND_tree
leaf_min_util	main.cpp	/^const double leaf_min_util = 0.3;$/;"	v
letter_entry	Leaf_node.h	/^    struct letter_entry{$/;"	s	class:Leaf_node
letters	Dir_node.h	/^      unsigned char letters[MAX_DMBR_DIM_SIZE]; \/\/ bitmap representation$/;"	m	struct:Dir_node::aux_tree_node
level	Dir_node.h	/^      int level; \/\/ level in the tree.  Leaf is level 1$/;"	m	struct:Dir_node::aux_tree_node
log2File	logClass.cpp	/^bool logClass::log2File( int infoInt , string fileName)$/;"	f	class:logClass
log2File	logClass.cpp	/^bool logClass::log2File(float infoFloat , string fileName)$/;"	f	class:logClass
log2File	logClass.cpp	/^bool logClass::log2File(string infoStr , string fileName)$/;"	f	class:logClass
log2File	logClass.cpp	/^bool logClass::log2File(unsigned int infoInt , string fileName)$/;"	f	class:logClass
log2file	Dir_node.h	/^void Dir_node::log2file( )$/;"	f	class:Dir_node
log2file	Leaf_node.h	/^void Leaf_node::log2file()$/;"	f	class:Leaf_node
logClass	logClass.cpp	/^logClass::logClass(void)$/;"	f	class:logClass
logClass	logClass.h	/^class logClass$/;"	c
logDMBR	Dir_node.h	/^void Dir_node::logDMBR( )$/;"	f	class:Dir_node
logDMBR	Leaf_node.h	/^void Leaf_node::logDMBR()$/;"	f	class:Leaf_node
logFlag	logClass.h	/^	bool logFlag;$/;"	m	class:logClass
logO	main.cpp	/^logClass logO;$/;"	v
logSingleChildDMBR	Dir_node.h	/^void Dir_node::logSingleChildDMBR(const unsigned char* const DMBR)$/;"	f	class:Dir_node
log_DMBR	Node.h	/^void Node::log_DMBR(const unsigned char* const DMBR)$/;"	f	class:Node
log_OneDirEntry_OnOneDscDim	Node.h	/^void Node::log_OneDirEntry_OnOneDscDim(  unsigned char*  DMBR, int dimNum,int* alphabet_sizes )$/;"	f	class:Node
log_OneEntry_OnOneDscDim	Dir_node.h	/^void Dir_node::log_OneEntry_OnOneDscDim( Dir_entry*  oneEntry,int entryIndex, int dimNum,int* alphabet_sizes )$/;"	f	class:Dir_node
log_OneEntry_OnOneDscDim	Leaf_node.h	/^void Leaf_node::log_OneEntry_OnOneDscDim(const Leaf_entry* const oneEntry,int entryIndex, int dimNum)$/;"	f	class:Leaf_node
lpad	utility.cpp	/^string lpad(string s, unsigned int str_len, string pad_s){$/;"	f
main	main.cpp	/^int main(int argc, char *argv[])$/;"	f
makeBoxQueryData	main.cpp	/^Dir_entry makeBoxQueryData(ifstream & query_file)$/;"	f
makeBoxQueryData_for_linearScan	main.cpp	/^vector< vector<int> >  makeBoxQueryData_for_linearScan(ifstream & query_file)$/;"	f
makeRandomBoxQueryData	main.cpp	/^Dir_entry makeRandomBoxQueryData(ifstream & query_file)$/;"	f
max_block_number	ND_tree.h	/^   unsigned int max_block_number; \/\/ The maximal block number now used in the tree, always increasing, start from 0$/;"	m	class:ND_tree
mixed_list_entry	Dir_node.h	/^   struct mixed_list_entry{$/;"	s	class:Dir_node
newtree	main.cpp	/^    bool newtree;$/;"	m	struct:options	file:
not_present	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	e	enum:Error_code
numLetters	Dir_node.h	/^	  int numLetters;	$/;"	m	struct:Dir_node::aux_tree_node
num_of_available_block_numbers	ND_tree.h	/^   unsigned int num_of_available_block_numbers; \/\/ Number of available block numbers stored in stack available_block_numbers$/;"	m	class:ND_tree
num_of_entry_set	Dir_node.h	/^	  int num_of_entry_set;$/;"	m	struct:Dir_node::set_entry
num_of_sets	Dir_node.h	/^	  int num_of_sets;$/;"	m	struct:Dir_node::aux_tree_node
operator =	Dir_node.h	/^	  aux_tree_node& operator=(const aux_tree_node& orig) {$/;"	f	struct:Dir_node::aux_tree_node
operator =	Dir_node.h	/^	  set_entry& operator=(const set_entry& orig) {$/;"	f	struct:Dir_node::set_entry
options	main.cpp	/^struct options$/;"	s	file:
overflow	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	e	enum:Error_code
parent	Dir_node.h	/^      int parent; \/\/ index of parent$/;"	m	struct:Dir_node::aux_tree_node
print_OneEntry_OnOneDscDim	Dir_node.h	/^void Dir_node::print_OneEntry_OnOneDscDim( Dir_entry*  oneEntry,int entryIndex, int dimNum,int* alphabet_sizes )$/;"	f	class:Dir_node
print_OneEntry_OnOneDscDim	Leaf_node.h	/^void Leaf_node::print_OneEntry_OnOneDscDim(const Leaf_entry* const oneEntry,int entryIndex, int dimNum)$/;"	f	class:Leaf_node
print_information	ND_tree.h	/^void ND_tree::print_information(){$/;"	f	class:ND_tree
range	main.cpp	/^    float range;$/;"	m	struct:options	file:
range_err	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	e	enum:Error_code
range_query_by_Hamming_dist	ND_tree.h	/^Error_code ND_tree::range_query_by_Hamming_dist(const Leaf_entry& query_data, int range, Leaf_entry* query_results, int &number_of_query_results, int &number_of_io){$/;"	f	class:ND_tree
read_existing_tree	ND_tree.h	/^void ND_tree::read_existing_tree(string ND_file_n)$/;"	f	class:ND_tree
read_node	Leaf_node.h	/^void Leaf_node::read_node(fstream& ND_file, unsigned int block_number)$/;"	f	class:Leaf_node
read_node_dynamic	Dir_node.h	/^void Dir_node::read_node_dynamic(fstream& ND_file, unsigned int block_number){$/;"	f	class:Dir_node
read_node_static	Dir_node.h	/^void Dir_node::read_node_static(fstream& ND_file, unsigned int block_number){$/;"	f	class:Dir_node
read_tree_info	ND_tree.h	/^void ND_tree::read_tree_info(fstream& ND_file)$/;"	f	class:ND_tree
record	Leaf_entry.h	/^    ND_tree_record record;    $/;"	m	struct:Leaf_entry
record_count	Leaf_entry.h	/^    ND_tree_record_count record_count; \/\/ Actual data, usually a pointer$/;"	m	struct:Leaf_entry
recordfile	main.cpp	/^    string recordfile;$/;"	m	struct:options	file:
resizeSetEntry	Dir_node.h	/^	  void resizeSetEntry(int numSet)$/;"	f	struct:Dir_node::set_entry
resizeSets	Dir_node.h	/^	  void resizeSets(int numSet)$/;"	f	struct:Dir_node::aux_tree_node
retrieve	Leaf_node.h	/^Error_code Leaf_node::retrieve(Leaf_entry& query_data)$/;"	f	class:Leaf_node
retrieve_by_box_query_use_link_v2	Leaf_node.h	/^Error_code Leaf_node::retrieve_by_box_query_use_link_v2($/;"	f	class:Leaf_node
retrieve_by_hamming_dist	Leaf_node.h	/^Error_code Leaf_node::retrieve_by_hamming_dist(const Leaf_entry& query_data, int range, Leaf_entry * query_results, int& number_of_query_results,int& number_of_io)$/;"	f	class:Leaf_node
root	ND_tree.h	/^   unsigned int root; \/\/ Root block number$/;"	m	class:ND_tree
rqfile	main.cpp	/^    string rqfile;\/\/ range query file$/;"	m	struct:options	file:
set	Dir_node.h	/^      unsigned char set[MAX_DMBR_DIM_SIZE]; \/\/ bitmap$/;"	m	struct:Dir_node::set_entry
set_DMBR	Dir_node.h	/^void Dir_node::set_DMBR(int entry_index, unsigned char* new_DMBR, bool& not_same){$/;"	f	class:Dir_node
set_count	Dir_node.h	/^      int set_count;$/;"	m	struct:Dir_node::aux_tree_node
set_entry	Dir_node.h	/^	  set_entry(){$/;"	f	struct:Dir_node::set_entry
set_entry	Dir_node.h	/^	  set_entry(const set_entry& orig) {$/;"	f	struct:Dir_node::set_entry
set_entry	Dir_node.h	/^   struct set_entry{$/;"	s	class:Dir_node
set_equal	Node.h	/^bool Node::set_equal(unsigned char* set1, unsigned char* set2, int byte_size)$/;"	f	class:Node
set_intersect	Node.h	/^void Node::set_intersect(unsigned char* set1, unsigned char* set2, int byte_size, unsigned char* intersect_set, bool& is_intersect)$/;"	f	class:Node
set_node_count	Dir_node.h	/^void Dir_node::set_node_count(int new_count){$/;"	f	class:Dir_node
set_node_count	Leaf_node.h	/^void Leaf_node::set_node_count(int new_count)$/;"	f	class:Leaf_node
set_node_entry	Dir_node.h	/^void Dir_node::set_node_entry(int index, Dir_entry& new_entry){$/;"	f	class:Dir_node
set_node_entry	Dir_node.h	/^void Dir_node::set_node_entry(int index, unsigned int new_entry_block_no, unsigned char* new_entry_DMBR){$/;"	f	class:Dir_node
set_node_entry	Leaf_node.h	/^void Leaf_node::set_node_entry(int index, Leaf_entry new_entry)$/;"	f	class:Leaf_node
set_size	Node.h	/^int Node::set_size(unsigned char* bitmap_set, int byte_size)$/;"	f	class:Node
setlogFlag	logClass.cpp	/^void logClass::setlogFlag(bool value)$/;"	f	class:logClass
sets	Dir_node.h	/^      int *sets; \/\/ array of indices into set_array$/;"	m	struct:Dir_node::aux_tree_node
skip	main.cpp	/^    long skip;$/;"	m	struct:options	file:
sort_entries_by_size	Dir_node.h	/^void Dir_node::sort_entries_by_size(int sort_dim, Dir_entry* sort_entries, int num_of_sort_entries, int* sorted_entry_list){$/;"	f	class:Dir_node
sort_entries_by_size	Leaf_node.h	/^void Leaf_node::sort_entries_by_size(int sort_dim, Leaf_entry* sort_entries, int num_of_sort_entries, int* sorted_entry_list)$/;"	f	class:Leaf_node
sort_entries_by_size_RANDOM_UTIL	Dir_node.h	/^int Dir_node::sort_entries_by_size_RANDOM_UTIL($/;"	f	class:Dir_node
sort_entries_by_size_RANDOM_UTIL	Leaf_node.h	/^int Leaf_node::sort_entries_by_size_RANDOM_UTIL(int sort_dim, Leaf_entry* sort_entries, int num_of_sort_entries, int* sorted_entry_list){$/;"	f	class:Leaf_node
sort_entries_by_size_RANDOM_UTIL_v2	Leaf_node.h	/^int Leaf_node::sort_entries_by_size_RANDOM_UTIL_v2($/;"	f	class:Leaf_node
sort_entries_by_size_RANDOM_UTIL_v3	Leaf_node.h	/^int Leaf_node::sort_entries_by_size_RANDOM_UTIL_v3($/;"	f	class:Leaf_node
sort_entries_by_size_Random_Util_v2	Dir_node.h	/^void Dir_node::sort_entries_by_size_Random_Util_v2(int sort_dim, Dir_entry* sort_entries, int num_of_sort_entries, $/;"	f	class:Dir_node
sort_entries_by_size_Random_Util_v3	Dir_node.h	/^void Dir_node::sort_entries_by_size_Random_Util_v3($/;"	f	class:Dir_node
split_TO_DEATH_RANDOM_UTIL	Dir_node.h	/^void Dir_node::split_TO_DEATH_RANDOM_UTIL(Dir_entry* split_entries, double dir_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Dir_node
split_TO_DEATH_RANDOM_UTIL	Leaf_node.h	/^void Leaf_node::split_TO_DEATH_RANDOM_UTIL(Leaf_entry* split_entries, double leaf_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Leaf_node
split_TO_DEATH_RANDOM_UTIL_v2	Dir_node.h	/^void Dir_node::split_TO_DEATH_RANDOM_UTIL_v2(Dir_entry* split_entries, double dir_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Dir_node
split_TO_DEATH_RANDOM_UTIL_v3	Dir_node.h	/^void Dir_node::split_TO_DEATH_RANDOM_UTIL_v3(Dir_entry* split_entries, double dir_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Dir_node
split_TO_DEATH_RANDOM_UTIL_v3	Leaf_node.h	/^void Leaf_node::split_TO_DEATH_RANDOM_UTIL_v3(Leaf_entry* split_entries, double leaf_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Leaf_node
split_TO_DEATH_RANDOM_UTIL_v4	Dir_node.h	/^void Dir_node::split_TO_DEATH_RANDOM_UTIL_v4(Dir_entry* split_entries, double dir_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Dir_node
split_TO_DEATH_RANDOM_UTIL_v4	Leaf_node.h	/^void Leaf_node::split_TO_DEATH_RANDOM_UTIL_v4(Leaf_entry* split_entries, double leaf_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Leaf_node
split_algorithm	Dir_node.h	/^void Dir_node::split_algorithm(Dir_entry* split_entries, double dir_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2){$/;"	f	class:Dir_node
split_algorithm	Leaf_node.h	/^void Leaf_node::split_algorithm(Leaf_entry* split_entries, double leaf_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Leaf_node
split_algorithm_TO_DEATH	Dir_node.h	/^void Dir_node::split_algorithm_TO_DEATH(Dir_entry* split_entries, double dir_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Dir_node
split_algorithm_TO_DEATH	Leaf_node.h	/^void Leaf_node::split_algorithm_TO_DEATH(Leaf_entry* split_entries, double leaf_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Leaf_node
split_algorithm_after_knapsack	Dir_node.h	/^void Dir_node::split_algorithm_after_knapsack(Dir_entry* split_entries, double dir_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Dir_node
split_algorithm_after_knapsack	Leaf_node.h	/^void Leaf_node::split_algorithm_after_knapsack(Leaf_entry* split_entries, double leaf_min_util, int* alphabet_sizes, int* group1, int &count1, int* group2, int &count2, unsigned char* DMBR1, unsigned char* DMBR2)$/;"	f	class:Leaf_node
string2binary	utility.cpp	/^void string2binary(const string &origString, unsigned char* const ptr)$/;"	f
string_to_int	logClass.cpp	/^int logClass::string_to_int(string s){$/;"	f	class:logClass
string_to_int	utility.cpp	/^int string_to_int(string s){$/;"	f
success	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	e	enum:Error_code
tmp_DMBR_bit_lut	main.cpp	/^int tmp_DMBR_bit_lut[DIM][MAX_ALPHABET_SIZE]; \/\/ Given a dim and a letter, store the coresponding bit in DMBR$/;"	v
tmp_DMBR_byte_lut	main.cpp	/^int tmp_DMBR_byte_lut[DIM][MAX_ALPHABET_SIZE]; \/\/ Given a dim and a letter, store the coresponding byte in DMBR$/;"	v
tree_size	ND_tree.h	/^   unsigned int tree_size; \/\/ Total number of entries inserted into the tree$/;"	m	class:ND_tree
underflow	utility.h	/^enum Error_code { duplicate_error, not_present, success, overflow, underflow, range_err, fail };$/;"	e	enum:Error_code
verify	ND_tree.h	/^void ND_tree::verify(){$/;"	f	class:ND_tree
weight	Dir_node.h	/^      int weight; \/\/ for roots only$/;"	m	struct:Dir_node::mixed_list_entry
write_node	Leaf_node.h	/^void Leaf_node::write_node(fstream& ND_file, unsigned int block_number)$/;"	f	class:Leaf_node
write_node_dynamic	Dir_node.h	/^void Dir_node::write_node_dynamic(fstream& ND_file, unsigned int block_number){$/;"	f	class:Dir_node
write_node_static	Dir_node.h	/^void Dir_node::write_node_static(fstream& ND_file, unsigned int block_number){$/;"	f	class:Dir_node
write_tree_info	ND_tree.h	/^void ND_tree::write_tree_info(fstream& ND_file)$/;"	f	class:ND_tree
~ND_tree	ND_tree.h	/^ND_tree::~ND_tree(){$/;"	f	class:ND_tree
~aux_tree_node	Dir_node.h	/^	  ~aux_tree_node(){delete []sets ;}$/;"	f	struct:Dir_node::aux_tree_node
~logClass	logClass.cpp	/^logClass::~logClass(void)$/;"	f	class:logClass
~set_entry	Dir_node.h	/^	  ~set_entry(){delete []entry_set ;}$/;"	f	struct:Dir_node::set_entry
